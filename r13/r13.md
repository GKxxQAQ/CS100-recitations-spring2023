---
marp: true
math: mathjax
---

# CS100 Recitation 13

GKxx

---

## Contents

- 重载运算符：总结、补充
- STL

---

# 重载运算符 (Operator overloading)

---

## 总结：技术

运算符重载的方式是定义一个名为 `operator@` 的函数：

- 各个运算对象从左向右依次作为这个函数的参数。
- 如果是成员函数，则最左侧的运算对象绑定到 `*this`。

不能发明新的运算符。不能为内置类型定义运算符。

不能被重载：

- `?:`, `.`, `::` 等，具有特别意义的运算符

不建议被重载：（为什么？）

- `&&`, `||`, `,`, `&` (address-of)

---

## 总结：技术

运算符重载的方式是定义一个名为 `operator@` 的函数：

- 各个运算对象从左向右依次作为这个函数的参数。
- 如果是成员函数，则最左侧的运算对象绑定到 `*this`。

不能发明新的运算符。不能为内置类型定义运算符。

不能被重载：

- `?:`, `.`, `::` 等，具有特别意义的运算符
- `?:` 无法被重载，因为它有一个运算对象不被求值，这一点用函数传参不可能做到

不建议被重载：（为什么？）

- `&&`, `||`, `,`, `&` (一元取地址运算符)
- `&&` 和 `||` 的短路求值会失效。`,` 和 `&` 本来就有特殊含义

---

## 总结：技术

重载的行为需要和内置的行为保持某种程度上的一致，除非你有很好的理由不这么做

- `++i` 返回 `i` 的引用，`i++` 返回递增前的 `i` 的一份拷贝。
- 赋值、复合赋值都返回左侧运算对象的引用。
- 解引用 `*p` 通常返回左值引用
- 比较运算符需要符合逻辑：`a == b` 意味着 `b == a`，`a != b` 意味着 `!(a == b)`。

C++20 的比较运算符的相关规则发生了巨大的变化：

- 允许用 `=default` 让编译器合成
- 新增了 `operator<=>` 用来定义数学上对应的**序关系**（partial ordering, strong ordering, weak ordering）
- 定义了 `operator==` 和 `operator<=>` 后编译器会合成六个关系运算符。

---

## 总结：技术

通常是成员：`++`, `--`, `*` (解引用), `->`, `=` (赋值，必须是成员), 各种复合赋值运算符（`+=`, `-=`, ...）

成员或非成员皆可：比较运算符 `<`, `<=`, `>`, `>=`, `==`, `!=`，算术运算符等

**如果需要左侧运算对象也能隐式转换，则它不能是成员。**

- `r == 1` 被视为 `r.operator==(1)`，即 `r.operator==(Rational(1))`
- 但 `1 == r` 无法被视为 `1.operator==(r)`。

---

## 不要漏 `const`！

```cpp
class Rational {
 public:
  bool operator==(const Rational &) const;
};
bool operator!=(const Rational &, const Rational &);
```

非成员有两个 `const`，成员也必然有两个 `const`，只是其中一个变成了这个成员函数的 qualifier。

---

## 特殊的运算符：后置递增 `i++`

```cpp
class Rational {
 public:
  Rational &operator++();
  // 90% 的后置递增运算符都应该这样写
  Rational operator++(int) {
    auto tmp = *this; // 拷贝原来的对象
    ++*this;          // 真正的“递增”由前置版本完成
    return tmp;       // 返回递增前的拷贝
  }
};
```

- `int` 参数：**仅仅是为了区分前置版本和后置版本**，没有实际意义，也不需要用到，自然也就没有名字。
- `++i` 被视为 `i.operator++()`，`i++` 被视为 `i.operator++(0)`。

---

## 特殊的运算符：`->`

```cpp
class SharedPtr {
 public:
  Object &operator*() const;
  Object *operator->() const {
    return std::addressof(this->operator*());
  }
};
```

- 为了让 `p->mem` 和 `(*p).mem` 等价，`operator->` 几乎总是应该这样定义。
- 注意在本例中 `operator*` 和 `operator->` 都是 `const`：它们都允许在 `const SharedPtr` 上调用。

---

## 避免重复：比较运算符

定义 `operator==` 和 `operator<`，让剩下四个依赖于它们。

```cpp
bool operator!=(const Rational &lhs, const Rational &rhs) {
  return !(lhs == rhs);
}
bool operator>(const Rational &lhs, const Rational &rhs) {
  return rhs < lhs;
}
bool operator<=(const Rational &lhs, const Rational &rhs) {
  return !(lhs > rhs); // 你只会 lhs < rhs || lhs == rhs ?
}
bool operator>=(const Rational &lhs, const Rational &rhs) {
  return !(lhs < rhs);
}
```

---

## 避免重复：算术运算符

定义一元负号 `-` 和 `+=`，那么 `+`, `-`, `-=` 都可以用它们实现。

```cpp
class Rational {
 public:
  Rational &operator-=(const Rational &rhs) {
    return *this += -rhs;
  }
};
Rational operator+(const Rational &lhs, const Rational &rhs) {
  return Rational(lhs) += rhs;
}
Rational operator-(const Rational &lhs, const Rational &rhs) {
  return Rational(lhs) -= rhs;
}
```

---

## 输入、输出运算符：`operator<<` 和 `operator>>`

首先搞清楚：输入流（例如 `std::cin`）的类型是 `std::istream`，输出流（例如 `std::cout`）的类型是 `std::ostream`。

这两个运算符应该是成员还是非成员？

---

## 输入、输出运算符

`operator<<` 和 `operator>>`

首先搞清楚：输入流（例如 `std::cin`）的类型是 `std::istream`，输出流（例如 `std::cout`）的类型是 `std::ostream`。

这两个运算符只能是非成员：你无法给 `std::istream` 和 `std:ostream` 添加成员。

`std::istream` 和 `std::ostream` 都不能拷贝，必须按引用传递，而且不能是常量引用。

```cpp
std::istream &operator>>(std::istream &, Rational &r);
std::ostream &operator<<(std::ostream &, const Rational &r);
```

- 为了支持连续的输入输出 `std::cin >> a >> b >> c`，这两个运算符需要把左侧运算对象返回出来。

---

## 输入、输出运算符

输入运算符需要考虑输入错误的情况：见客观题 18。

```cpp
struct Vec3 {
  double x_, y_, z_;
  double l2_norm_;
};
std::istream &operator>>(std::istream &is, Vec3 &v) {
  is >> v.x_ >> v.y_ >> v.z_;
  if (!is) // 如果输入发生错误，要将对象置于有效的状态。
    v.x_ = v.y_ = v.z_ = 0;
  v.l2_norm_ = std::sqrt(v.x_ * v.x_ + v.y_ * v.y_ + v.z_ * v.z_);
  return is;
}
```

---

## 输入、输出运算符

不能直接将 `is`、`os` 替换为 `std::cin` 和 `std::cout`：除它们之外还有其它的流对象

```cpp
std::ifstream file("infile.txt");
int x, y, z;
file >> x >> y >> z;
```

由于 `std::ifstream` 继承自 `std::istream`，它可以被 `std::istream &` 绑定

后面课程会讲

---

## 避免重载运算符的滥用

函数的名称可以透露很多信息，而运算符不行：

- `a * b` 和 `dot_product(a, b)`
- `a < b` 和 `compare_by_id(a, b)`
- `a + b` 和 `concat(a, b)`

避免滥用重载运算符：除非这个运算符有唯一明确合理的定义，否则不要定义它。

- 为什么 `std::string` 可以用 `+` 连接，而 `std::vector` 不行？
- MATLAB 的 `a * b` 和 `a .* b` 的区别

`operator+` 应该加而不是减，`operator<` 应该是“小于”而非“大于”。

---

## 函数调用运算符 `operator()`

这块内容我放在 STL 部分了，但仍然属于重载运算符的板块。

```cpp
struct Adder {
  int operator()(int a, int b) const {
    return a + b;
  }
};
std::cout << Adder{}(2, 3) << std::endl; // 5
```

- `Adder{}` 创建了一个 `Adder` 类型的对象
- `Adder{}(2, 3)` 相当于 `Adder{}.operator()(2, 3)`

一般地，`f(arg1, arg2, ...)` 被视为 `f.operator()(arg1, arg2, ...)`。

---

## 类型转换运算符

