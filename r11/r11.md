---
marp: true
math: mathjax
---

# CS100 Recitation 11

GKxx

---

## Contents

- 拷贝控制实例：Message and Folder
- 多文件和动态链接
- 继承：梳理

---

# 拷贝控制实例

---

## Message and Folder

考虑一个邮件系统：

- 一个 Folder 中包含一些 Message
- 一个 Message 可能存在于多个 Folder 中，但我们不希望拷贝 Message 的内容

复制一个 Message：复制其内容，并且将新的 Message 也加入相应的 Folder

复制一个 Folder：将它包含的所有 Message 也加入新的 Folder

---

## Message and Folder

```cpp
class Message {
  std::string m_contents;
  std::set<Folder *> m_folders;
};
class Folder {
  std::set<Message *> m_messages;
};
```

快速地插入、删除、查找元素的“集合”数据结构：`std::set`（标准库文件 `<set>`）

\* 编译器报错了？

```
error: ‘Folder’ was not declared in this scope
    6 |   std::set<Folder *> m_folders;
      |            ^~~~~~
```

---

## Message and Folder

“循环依赖”的情形：`Message` 需要 `Folder`，`Folder` 需要 `Message`。

- 无论谁在前，都会有一个名字查找发生失败。

幸好，这里不完全类型就足够了

- 我们只是使用了 `Folder*` 和 `Message*`
- 没有创建其对象，没有使用其成员

所以在前面补一个声明即可。

---

## Message and Folder

```cpp
class Folder; // declaration
class Message {
  std::string m_contents;
  std::set<Folder *> m_folders;
};
class Folder {
  std::set<Message *> m_messages;
};
```

先写几个简单的成员函数：添加一个 message，添加一个 folder 等等。

---

## Message and Folder

`s.insert(x)` 向集合 `s` 添加一个元素；`s.erase(x)` 从 `s` 中删除元素 `x`。

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>

```cpp
class Message {
  std::string m_contents;
  std::set<Folder *> m_folders;
 public:
  void addFolder(Folder &folder) {
    m_folders.insert(&folder);
  }
  void removeFolder(Folder &folder) {
    m_folders.erase(&folder);
  }
};
```
  </div>
  <div>

```cpp
class Folder {
  std::set<Message *> m_messages;
 public:
  void addMessage(Message &msg) {
    m_messages.insert(&msg);
  }
  void removeMessage(Message &msg) {
    m_messages.erase(&msg);
  }
};
```
  </div>
</div>

有没有哪个地方应该使用 `const`？

---

## Message and Folder

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>

```cpp
class Message {
  std::string m_contents;
  std::set<Folder *> m_folders;
 public:
  void addFolder(Folder &folder) {
    m_folders.insert(&folder);
  }
  void removeFolder(Folder &folder) {
    m_folders.erase(&folder);
  }
};
```

有没有哪个地方应该使用 `const`？
  </div>
  <div>

- 表面上看，`addFolder` 和 `removeFolder` 不改变被添加的 `folder`
- 但如果声明为 `const Folder &folder`，就意味着 `m_folders` 里的元素也应该是 `const Folder *`。
- 而我们存储这些 `Folder` 的指针，以后必然需要调用它们的 non-`const` 操作（例如添加、删除信息）。
- 因此，`addFolder` 和 `removeFolder` 应该将那些不能修改的 `Folder` 拒之门外，所以这里不能带 `const`。
  </div>
</div>

---

## Message and Folder

`Message` 的构造函数：接受一个字符串作为信息的内容。

```cpp
class Message {
 public:
  // 拷贝左值，移动右值
  Message(std::string contents) : m_contents{std::move(contents)} {}
};
```

---

## Message and Folder

`Message` 的拷贝操作：

```cpp
class Message {
 public:
  Message(const Message &other)
    : m_contents{other.m_contents}, m_folders{other.m_folders} {
    for (auto f : m_folders)
      f->addMessage(*this);
  }
  ~Message() {
    for (auto f : m_folders)
      f->removeMessage(*this);
  }
};
```

---

## Message and Folder

`Message` 的拷贝操作：

```cpp
class Message {
 public:
  Message &operator=(const Message &other) {
    for (auto f : m_folders)
      f->removeMessage(*this);
    m_contents = other.m_contents;
    m_folders = other.m_folders;
    for (auto f : m_folders)
      f->addMessage(*this);
    return *this;
  }
};
```

避免重复：写两个 `private` 函数来实现“将自身添加到所有文件夹/从所有文件夹中删除”的功能。

---

## Message and Folder

`Message` 的移动操作：移动 `m_contents`，但我们仍然需要将自身从原来的文件夹中删除，以及添加到所有新的文件夹中。

很遗憾，这个操作无法 `noexcept`。

```cpp
class Message {
 public:
  Message(Message &&other) : m_contents{std::move(other.m_contents)} {
    moveFolders(other);
  }
 private:
  void moveFolders(Message &other) {
    other.removeFromAll();
    m_folders = std::move(other.m_folders);
    addToAll();
  }
};
```

---

## Message and Folder

`Message` 的移动操作：移动 `m_contents`，但我们仍然需要将自身从原来的文件夹中删除，以及添加到所有新的文件夹中。

很遗憾，这个操作无法 `noexcept`。

```cpp
class Message {
 public:
  Message &operator=(Message &&other) {
    if (this != &other) {
      removeFromAll();
      m_contents = std::move(other.m_contents);
      moveFolders(other);
    }
    return *this;
  }
};
```

---

## 循环依赖

出现了问题：现在我们不得不使用 `Folder` 的成员函数，但这要求 `Folder` 不是一个不完全类型（其定义必须已经给出）。

如果交换两个类的顺序，同样的问题会在 `Folder` 中发生。

---

## 循环依赖

出现了问题：现在我们不得不使用 `Folder` 的成员函数，但这要求 `Folder` 不是一个不完全类型（其定义必须已经给出）。

如果交换两个类的顺序，同样的问题会在 `Folder` 中发生。

解决方案：**在类内声明函数，等到 `Folder` 的定义给出之后再定义。**

---

## 循环依赖

```cpp
class Message {
 private:
  void addToAll();
  void removeFromAll();
};
class Folder {
  // ...
};
void Message::addToAll() {
  for (auto f : m_folders)
    f->addMessage(&this);
}
void Message::removeFromAll() {
  for (auto f : m_folders)
    f->removeMessage(&this);
}
```
