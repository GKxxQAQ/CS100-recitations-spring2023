---
marp: true
math: mathjax
---

# CS100 Recitations 6

GKxx

---

## Contents

- Homework 3 讲评
- `struct`
- C++ 的开始
- 初识 `iostream` 和 `std::string`

---

# Homework 3

---

## 你真的了解 `fgets` 吗？

- `fgets` 至多读取输入中的几个字符？
- `fgets` 碰到换行符时会终止，换行符读了没有？如果读了，存了没有？
- `fgets` 会在末尾放 `'\0'` 吗？

---

## 你真的了解 `fgets` 吗？

- `fgets` 至多读取输入中的几个字符？
- `fgets` 碰到换行符时会终止，换行符读了没有？如果读了，存了没有？
- `fgets` 会在末尾放 `'\0'` 吗？

[答案在这里](https://en.cppreference.com/w/c/io/fgets)

**如果你只是道听途说 “`fgets` 可以读一行” 就在代码里用它，这就是通向彻夜调试大会的直达车票。**

---

## 1. 简单题

用 ASCII 码循环移动一下就好了。

**不需要存输入的字符串，读一个处理一个就行**

不会 [ASCII 码](https://en.cppreference.com/w/cpp/language/ascii)？你将无法做 HW4

---

## 2. 规则说起来有点麻烦

给一个 keyword（例如 `Wednesday`），首先制作一个表，分为以下几步：
1. 去重，填入前几位：`wednsay`
2. 从最后一个字母（`y`）开始顺着往后接，跳过前面出现过的字母，到 `z` 则循环：`wednsayzbcfghijklmopqrtuvx`
3. 将以上内容视为一个数组 `char encoding[26];`，`encoding[i]` 对应了 `i + 'a'`（或者 `i + 'A'`），按照这个对应关系处理输入的每个字符。

---

## 去重，填入前几位

```c
int len_keyword = strlen(keyword);
bool used[26] = {0};
int len_encoding = 0;
for (int i = 0; i != len_keyword; ++i) {
  char ch = tolower(keyword[i]);
  if (!used[ch - 'a']) {
    used[ch - 'a'] = true;
    encoding[len_encoding++] = ch;
  }
}
assert(len_encoding < 26);
```

---

## 接着往后填

继续使用 `used` 数组

```c
char ch = encoding[len_encoding - 1];
while (len_encoding < 26) {
  while (used[ch - 'a'])
    ch = (ch == 'z') ? 'a' : (ch + 1);
  used[ch - 'a'] = true;
  encoding[len_encoding++] = ch;
}
```

---

## 处理输入

密文根本不用存，来一个走一个（没人规定读完所有输入才能开始输出）

```c
char ch;
while ((ch = getchar()) != EOF && ch != '\n')
  putchar(decode(ch));
```

不要看到一串文本，就想到字符串，就想到 `fgets` 读入，就想到开数组存储。~~你们的想象惟在这一层能够如此跃进~~

---

## decode

暴力：直接在 `encoding` 数组里找

```c
char decode(char ch) {
  if (isalpha(ch)) {
    int pos = -1;
    for (int i = 0; i != 26; ++i)
      if (encoding[i] == ch) {
        pos = i;
        break;
      }
    assert(pos != -1);
    return pos + 'a';
  } else
    return ch;
}
```

---

## decode

大写与小写仅有一步之遥，没有本质区别。

```c
char decode(char ch) {
  if (isalpha(ch)) {
    bool is_upper = isupper(ch);
    ch = tolower(ch);
    int pos = -1;
    for (int i = 0; i != 26; ++i)
      if (encoding[i] == ch) {
        pos = i;
        break;
      }
    assert(pos != -1);
    return pos + (is_upper ? 'A' : 'a');
  } else
    return ch;
}
```

---

## 3. [回文日期](https://www.luogu.com.cn/problem/P2010) 加强版

一年至多可能有多少个回文日期？

---

## 4. 找最喜欢的游戏类型

每个游戏有一个 price 和一个 type，type 为 $10^6$ 以内的正整数。找出 price 总和最大的那个 type。

**游戏名字根本没有用**：`scanf` 的 `%` 和 conversion format specifier 之间加个 `*` 就表示只匹配、不存储。
- https://en.cppreference.com/w/c/io/fscanf#Parameters
- 或者用循环 + `getchar` 跳过。

---

## 4. 找最喜欢的游戏类型

每个游戏有一个 price 和一个 type，type 为 $10^6$ 以内的正整数。找出 price 总和最大的那个 type。

- 开个数组 `long long price_sum_of_type[1000001];`
- 对于每个游戏，`price_sum_of_type[type] += price;`
- 枚举所有可能的 `type`，找出 `price_sum_of_type[type]` 最大的那个。
  - 可以 `for (int type = 1; type <= 1000000; ++type)`
  - 也可以在读入的时候顺便记下 `type` 的最大值，缩小枚举范围。

---

## 学会计算内存用量

```c
struct Game {
  char name[10000001];
  int price;
  int type;
};

Game games[1000000];
```

你花了 $\dfrac{10^7\times 10^6}{1024\times 1024\times 1024}\approx 9300$ **GB** 来存储那一堆没有用的名字。

---

## 5. 二维版 [玩具谜题](https://www.luogu.com.cn/problem/P1563)

首先还是那个问题：你真的需要开数组存某个东西吗？

- 读完了 $r,c,q$、朝向信息以及起始位置之后，就可以读一步、动一步。
- 发现 Mistake 了就直接结束：**没人规定你必须把输入全读完**

---

## 判断一个位置是否走过

和刚才那个 `used` 类似的做法：

```c
bool visited[501][501];

for (int i = 0; i != q; ++i) {
  // 输入这一步的方向、距离
  // 算出新的位置 (row, col)
  if (valid_coord(row, col) && !visited[row][col]) {
    printf("(%d, %d)\n", row, col);
    visited[row][col] = true;
  } else {
    puts("Mistake!");
    break;
  }
}
```

---

## 朝向、方向，一共 16 种情况，如何避免重复？

- 朝向：以“向上”为基准，“向上”、“向右”、“向下”、“向左”分别是顺时针转 $0^\circ$, $90^\circ$, $180^\circ$, $270^\circ$
- 在我的“前”/“右”/“后”/“左”方：再顺时针转 $0^\circ$ / $90^\circ$ / $180^\circ$ / $270^\circ$
- 角度加起来对 $360^\circ$ 取模，就是实际转了多少度，对应四种情况。

---

## 朝向、方向，一共 16 种情况，如何避免重复？

- 朝向：以“向上”为基准，“向上”、“向右”、“向下”、“向左”分别是顺时针转 $0^\circ$, $90^\circ$, $180^\circ$, $270^\circ$
- 在我的“前”/“右”/“后”/“左”方：再顺时针转 $0^\circ$ / $90^\circ$ / $180^\circ$ / $270^\circ$
- 角度加起来对 $360^\circ$ 取模，就是实际转了多少度，对应四种情况。
- 将四个朝向和四个方向都按顺序编码为 `0`, `1`, `2`, `3`
  - 只要看 `(direction + face) % 4`

---

# `struct`

---

##