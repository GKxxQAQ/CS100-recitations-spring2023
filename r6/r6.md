---
marp: true
math: mathjax
---

# CS100 Recitations 6

GKxx

---

## Contents

- Homework 3 讲评
- `struct`
- C++ 的开始
- 初识 `iostream` 和 `std::string`

---

# Homework 3

---

## 你真的了解 `fgets` 吗？

- `fgets` 至多读取输入中的几个字符？
- `fgets` 碰到换行符时会终止，换行符读了没有？如果读了，存了没有？
- `fgets` 会在末尾放 `'\0'` 吗？

---

## 你真的了解 `fgets` 吗？

- `fgets` 至多读取输入中的几个字符？
- `fgets` 碰到换行符时会终止，换行符读了没有？如果读了，存了没有？
- `fgets` 会在末尾放 `'\0'` 吗？

[答案在这里](https://en.cppreference.com/w/c/io/fgets)

**如果你只是道听途说 “`fgets` 可以读一行” 就在代码里用它，这就是通向彻夜调试大会的直达车票。**

---

## 1. 简单题

用 ASCII 码循环移动一下就好了。

**不需要存输入的字符串，读一个处理一个就行**

不会 [ASCII 码](https://en.cppreference.com/w/cpp/language/ascii)？你将无法做 HW4

---

## 2. 规则说起来有点麻烦

给一个 keyword（例如 `Wednesday`），首先制作一个表，分为以下几步：
1. 去重，填入前几位：`wednsay`
2. 从最后一个字母（`y`）开始顺着往后接，跳过前面出现过的字母，到 `z` 则循环：`wednsayzbcfghijklmopqrtuvx`
3. 将以上内容视为一个数组 `char encoding[26];`，`encoding[i]` 对应了 `i + 'a'`（或者 `i + 'A'`），按照这个对应关系处理输入的每个字符。

---

## 去重，填入前几位

```c
int len_keyword = strlen(keyword);
bool used[26] = {0};
int len_encoding = 0;
for (int i = 0; i != len_keyword; ++i) {
  char ch = tolower(keyword[i]);
  if (!used[ch - 'a']) {
    used[ch - 'a'] = true;
    encoding[len_encoding++] = ch;
  }
}
assert(len_encoding < 26);
```

---

## 接着往后填

继续使用 `used` 数组

```c
char ch = encoding[len_encoding - 1];
while (len_encoding < 26) {
  while (used[ch - 'a'])
    ch = (ch == 'z') ? 'a' : (ch + 1);
  used[ch - 'a'] = true;
  encoding[len_encoding++] = ch;
}
```

---

## 处理输入

密文根本不用存，来一个走一个（没人规定读完所有输入才能开始输出）

```c
char ch;
while ((ch = getchar()) != EOF && ch != '\n')
  putchar(decode(ch));
```

不要看到一串文本，就想到字符串，就想到 `fgets` 读入，就想到开数组存储。~~你们的想象惟在这一层能够如此跃进~~

---

## decode

暴力：直接在 `encoding` 数组里找

```c
char decode(char ch) {
  if (isalpha(ch)) {
    int pos = -1;
    for (int i = 0; i != 26; ++i)
      if (encoding[i] == ch) {
        pos = i;
        break;
      }
    assert(pos != -1);
    return pos + 'a';
  } else
    return ch;
}
```

---

## decode

大写与小写仅有一步之遥，没有本质区别。

```c
char decode(char ch) {
  if (isalpha(ch)) {
    bool is_upper = isupper(ch);
    ch = tolower(ch);
    int pos = -1;
    for (int i = 0; i != 26; ++i)
      if (encoding[i] == ch) {
        pos = i;
        break;
      }
    assert(pos != -1);
    return pos + (is_upper ? 'A' : 'a');
  } else
    return ch;
}
```

---

## 3. [回文日期](https://www.luogu.com.cn/problem/P2010) 加强版

一年至多可能有多少个回文日期？

---

## 4. 找最喜欢的游戏类型

每个游戏有一个 price 和一个 type，type 为 $10^6$ 以内的正整数。找出 price 总和最大的那个 type。

**游戏名字根本没有用**：`scanf` 的 `%` 和 conversion format specifier 之间加个 `*` 就表示只匹配、不存储。
- https://en.cppreference.com/w/c/io/fscanf#Parameters
- 或者用循环 + `getchar` 跳过。

---

## 4. 找最喜欢的游戏类型

每个游戏有一个 price 和一个 type，type 为 $10^6$ 以内的正整数。找出 price 总和最大的那个 type。

- 开个数组 `long long price_sum_of_type[1000001];`
- 对于每个游戏，`price_sum_of_type[type] += price;`
- 枚举所有可能的 `type`，找出 `price_sum_of_type[type]` 最大的那个。
  - 可以 `for (int type = 1; type <= 1000000; ++type)`
  - 也可以在读入的时候顺便记下 `type` 的最大值，缩小枚举范围。

---

## 学会计算内存用量

```c
struct Game {
  char name[10000001];
  int price;
  int type;
};

Game games[1000000];
```

你花了 $\dfrac{10^7\times 10^6}{1024\times 1024\times 1024}\approx 9300$ **GB** 来存储那一堆没有用的名字。

---

## 5. 二维版 [玩具谜题](https://www.luogu.com.cn/problem/P1563)

首先还是那个问题：你真的需要开数组存某个东西吗？

- 读完了 $r,c,q$、朝向信息以及起始位置之后，就可以读一步、动一步。
- 发现 Mistake 了就直接结束：**没人规定你必须把输入全读完**

---

## 判断一个位置是否走过

和刚才那个 `used` 类似的做法：

```c
bool visited[501][501];

for (int i = 0; i != q; ++i) {
  // 输入这一步的方向、距离
  // 算出新的位置 (row, col)
  if (valid_coord(row, col) && !visited[row][col]) {
    printf("(%d, %d)\n", row, col);
    visited[row][col] = true;
  } else {
    puts("Mistake!");
    break;
  }
}
```

---

## 朝向、方向，一共 16 种情况，如何避免重复？

- 朝向：以“向上”为基准，“向上”、“向右”、“向下”、“向左”分别是顺时针转 $0^\circ$, $90^\circ$, $180^\circ$, $270^\circ$
- 在我的“前”/“右”/“后”/“左”方：再顺时针转 $0^\circ$ / $90^\circ$ / $180^\circ$ / $270^\circ$
- 角度加起来对 $360^\circ$ 取模，就是实际转了多少度，对应四种情况。

---

## 朝向、方向，一共 16 种情况，如何避免重复？

- 朝向：以“向上”为基准，“向上”、“向右”、“向下”、“向左”分别是顺时针转 $0^\circ$, $90^\circ$, $180^\circ$, $270^\circ$
- 在我的“前”/“右”/“后”/“左”方：再顺时针转 $0^\circ$ / $90^\circ$ / $180^\circ$ / $270^\circ$
- 角度加起来对 $360^\circ$ 取模，就是实际转了多少度，对应四种情况。
- 将四个朝向和四个方向都按顺序编码为 `0`, `1`, `2`, `3`
  - 只要看 `(direction + face) % 4`

---

## `valid_coord`

```c
bool valid_coord(int row, int col) {
  return row >= 1 && row <= r && col >= 1 && col <= c;
}
```

**不要再写啰嗦的 `return condition ? 1 : 0;` 了！！**

---

# `struct`

---

## `struct`

把几个东西结合在一起，定义成一个新的数据结构

<div style="display: grid; grid-template-columns: 1fr 1fr 1fr;">
  <div>

```c
struct Student {
  const char *name;
  const char *id;
  int entrance_year;
  int dorm;
};
```
  </div>
  <div>

```c
struct Record {
  void *ptr;
  size_t size;
  int line_no;
  const char *file_name;
};
```
  </div>
  <div>

```c
struct brainfuck_state {
  uint8_t *memory_buffer;
  size_t offset;
  // ...
};
```
  </div>
</div>

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>

```c
struct Point3d {
  double x, y, z;
}; 
```
  </div>
  <div>

```c
struct Line3d {
  Point3d p0, direction;
};
```
  </div>
</div>

---

## `struct` 类型

`struct` + 名字。C 中 `struct` 关键字不可省略，C++ 中必须省略。

```c
struct Student student;
struct Record records[1000];
```

### `typedef` 定义类型别名

```c
typedef long long LL;
typedef struct { double x, y, z; } Point3d;

LL llval = 0; // llval is long long
Point3d p;
```

**不要用 `#define` 代替 `typedef`**

---

## `struct` 的成员

`name.mem`

```c
struct Student student;
student.name = "Alice";
student.id = "2023533000";
student.entrance_year = 2023;
student.dorm = 8;
printf("%d\n", student.dorm);
++student.entrance_year;
puts(student.name);
```

---

## `struct` 的成员

`ptr->mem`：等价于 `(*ptr).name`。**不是 `*ptr.name` ！！**（`.` 优先级高于 `*`）

```c
struct Student *ptr = &student;
ptr->name = "Alice";
ptr->id = "2023533000";
(*ptr).entrance_year = 2023; // equivalent to ptr->entrance_year = 2023;
ptr->dorm = 8;
printf("%d\n", ptr->dorm);
++ptr->entrance_year;
puts(ptr->name);
```

---

## `struct` 初始化

老生常谈的问题：不显式初始化时会发生什么？

```c
struct Student gs;
int main(void) {
  struct Student ls;
}
```

---

## `struct` 初始化

老生常谈的问题：不显式初始化时会发生什么？

```c
struct Student gs;
int main(void) {
  struct Student ls;
}
```

- 全局或局部 `static`：**空初始化**：结构体的所有成员都被空初始化。
- 局部非 `static`：不初始化，所有成员都具有未定义的值。

---

## `struct` 的初始化

Initializer list:

```c
struct Record r = {p, cnt * each_size, __LINE__, __FILE__};
```

隔壁 C++20 才有的 designators，C99 就有了！（是不是非常像 Python？）

```c
struct Record r2 = {.ptr = p, .size = cnt * each_size,
                    .line_no = __LINE__, .file = __FILE__};
```

C 允许 designators 以任意顺序出现，C++不允许。

---

## `struct` 的初始化

```c
struct Record r = {p, cnt * each_size, __LINE__, __FILE__};
struct Record r2 = {.ptr = p, .size = cnt * each_size,
                    .line_no = __LINE__, .file = __FILE__};
```

**赋值**不行：

```c
r = {p, cnt * each_size, __LINE__, __FILE__};         // Error
records[i] = {.ptr = p, .size = cnt * each_size,
              .line_no = __LINE__, .file = __FILE__}; // Error
```

但加个类型转换就好了：

```c
r = (struct Record){p, cnt * each_size, __LINE__, __FILE__};         // OK
records[i] = (struct Record){.ptr = p, .size = cnt * each_size,
                             .line_no = __LINE__, .file = __FILE__}; // OK
```

---

## 在函数之间传递 `struct`

传参的语义是**拷贝**。

```c
void print_info(struct Record r) {
  printf("%p, %zu, %d, %s\n", r.ptr, r.size, r.line_no, r.file_name);
}

print_info(records[i]);
```

传参时发生了这样的**初始化**：

```c
struct Record r = records[i];
```

`struct` 的拷贝：**逐元素拷贝**。

---

## 在函数之间传递 `struct`

传参时发生了这样的**初始化**：

```c
struct Record r = records[i];
```

`struct` 的拷贝：**逐元素拷贝**。就如同

```c
r.ptr = records[i].ptr;
r.size = records[i].size;
r.line_no = records[i].line_no;
r.file_name = records[i].file_name;
```

---

## 在函数之间传递 `struct`

返回一个 `struct`：严格按照语法来说，也是**拷贝**：

```c
struct Record fun(void) {
  struct Record r = something();
  some_computations(r);
  return r;
}

records[i] = fun();
```

`return r;`：发生了形如 `struct Record tmp = r;` 的**拷贝**，临时对象 `tmp` 是表达式 `fun()` 的求值结果。然后发生了形如 `records[i] = tmp;` 的**拷贝**。

**但实际上这个过程会被编译器优化，标准也是允许这种优化的。**（我们以后在 C++ 里进一步讨论这个问题）

---

## 数组成员

```c
struct A {
  int array[10];
  // other members
};
```

虽然编译器拒绝直接拷贝数组，但它其实有能力做到。

拷贝一个 `struct A` 时，编译器会自动逐元素拷贝数组。

<div style="display: grid; grid-template-columns: 1fr 1fr;">
  <div>

```c
int a[10];
int b[10] = a; // Error!
```
  </div>
  <div>

```c
struct A a;
struct A b = a; // OK
```
  </div>
</div>

---

## `struct` 的大小

```c
struct A {
  int x;
  char y;
  double z;
};
```

`sizeof(A)` 是多少？

---

## `struct` 的大小

```c
struct A {
  int x;
  char y;
  double z;
};
```

`sizeof(A) >= sizeof(int) + sizeof(char) + sizeof(double)`。由于内存对齐的问题，编译器可能会在某些地方插入一定的空白。

---

## `struct` 的大小

```c
struct A {
  int x;
  struct A a;
};
```

`sizeof(A)` 是多少？

---

## `struct` 的大小

```c
struct A {
  int x;
  struct A a;
};
```

`sizeof(A)`$=+\infty$。因此这种行为是**不允许的**。

- 从物理上讲：这样的东西无法存储。
- C 类型系统认为：在 `};` 之前（定义完毕之前）这个类型是**不完全类型** (incomplete type)。对于不完全类型，不能定义这个类型的对象，不能访问这个类型的成员，只能定义这个类型的指针，并且不能解引用。


---

### 练习

考虑三维空间中的点 $(x,y,z)$ 以及直线 $\mathbf P(t)=\mathbf P_0+t\mathbf v$。定义 `struct` 表示这两个概念。定义一些函数，例如计算点到直线的距离、计算给定参数 $t$ 的值时的点、输出一些信息。试着使用 initializer list 和 designators 进行初始化。

```c
double dist(struct Point3d p, struct Line3d line);
struct Point3d line_at(struct Line3d line, double t);
```

---

### 练习

```c
struct Point3d {
  double x, y, z;
};
struct Line3d {
  struct Point3d p0, v;
};
struct Point3d line_at(struct Line3d line, double t) {
  return (struct Point3d) {
    .x = line.p0.x + t * line.v.x,
    .y = line.p0.y + t * line.v.y,
    .z = line.p0.z + t * line.v.z
  };
}
```

---

## 总结

没有总结。独立完成上面的练习即可真正理解 `struct`。

---

# C++ 的开始

---

